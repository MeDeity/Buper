<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>卷积层运作原理科普演示</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link rel="stylesheet" href="../style.css">
    
</head>
<body>
    <div class="container">
        <header>
            <h1><i class="fas fa-brain"></i> 卷积神经网络层运作原理</h1>
            <p class="subtitle">可视化演示卷积层如何从输入数据中提取特征，理解卷积核、步长、填充等关键概念</p>
        </header>
        
        <div class="content-wrapper">
            <section class="visualization-section">
                <div class="section-header">
                    <h2 class="section-title"><i class="fas fa-eye"></i> 卷积操作可视化</h2>
                    <div id="stepInfoDisplay" class="step-info-display">
                        <!-- 信息将通过JS动态插入 -->
                    </div>
                </div>
                <div id="canvas-container">
                    <canvas id="convCanvas"></canvas>
                </div>
                
                <div class="legend">
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #3b82f6;"></div>
                        <span>输入特征图</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #10b981;"></div>
                        <span>卷积核</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #f59e0b;"></div>
                        <span>输出特征图</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #ef4444;"></div>
                        <span>当前计算区域</span>
                    </div>
                </div>
                
                <div class="controls">
                    <div class="control-group">
                        <div class="control-title"><i class="fas fa-expand-alt"></i> 卷积核大小</div>
                        <div class="slider-container">
                            <input type="range" id="kernelSize" min="2" max="5" value="3" step="1">
                            <div class="slider-value" id="kernelSizeValue">3x3</div>
                        </div>
                    </div>
                    
                    <div class="control-group">
                        <div class="control-title"><i class="fas fa-ruler-horizontal"></i> 步长 (Stride)</div>
                        <div class="slider-container">
                            <input type="range" id="stride" min="1" max="3" value="1" step="1">
                            <div class="slider-value" id="strideValue">1</div>
                        </div>
                    </div>
                    
                    <div class="control-group">
                        <div class="control-title"><i class="fas fa-border-style"></i> 填充 (Padding)</div>
                        <div class="slider-container">
                            <input type="range" id="padding" min="0" max="2" value="0" step="1">
                            <div class="slider-value" id="paddingValue">0</div>
                        </div>
                    </div>
                    
                    <div class="control-group">
                        <div class="control-title"><i class="fas fa-tachometer-alt"></i> 动画速度</div>
                        <div class="slider-container">
                            <input type="range" id="speed" min="1" max="10" value="5" step="1">
                            <div class="slider-value" id="speedValue">5</div>
                        </div>
                    </div>
                </div>
                
                <div class="buttons">
                    <button id="startBtn"><i class="fas fa-play"></i> 开始卷积</button>
                    <button id="resetBtn" class="secondary"><i class="fas fa-redo"></i> 重置</button>
                    <button id="stepBtn" class="secondary"><i class="fas fa-step-forward"></i> 单步执行</button>
                </div>
            </section>
            
            <section class="explanation-section">
                <h2 class="section-title"><i class="fas fa-graduation-cap"></i> 卷积原理分步讲解</h2>
                
                <div class="formula">
                    输出尺寸 = ⌊(输入尺寸 + 2×填充 - 卷积核尺寸) / 步长⌋ + 1
                </div>
                
                <div class="step-container">
                    <div class="step active" id="step1">
                        <div class="step-title">步骤 1: 卷积核与输入对齐</div>
                        <div class="step-content">
                            <p>卷积操作从输入特征图的左上角开始。卷积核（绿色）与输入特征图（蓝色）的对应位置对齐。</p>
                            <p>卷积核中的每个权重与输入中的对应值相乘，然后将所有乘积相加，得到输出特征图中的一个值。</p>
                            <p>这个过程就像用一个"窗口"（卷积核）在输入特征图上滑动，每次计算窗口覆盖区域的特征。</p>
                        </div>
                    </div>
                    
                    <div class="step" id="step2">
                        <div class="step-title">步骤 2: 逐元素相乘与求和</div>
                        <div class="step-content">
                            <p>卷积核在当前位置与输入特征图的对应区域进行逐元素相乘。例如，如果卷积核大小为3×3，就会有9个乘法运算。</p>
                            <p>然后将这9个乘积结果相加，得到一个单一的输出值。这个值反映了输入区域与卷积核的匹配程度。</p>
                            <p>如果卷积核检测的特征（如边缘、纹理）在输入区域中存在，输出值会较大；否则输出值较小。</p>
                        </div>
                    </div>
                    
                    <div class="step" id="step3">
                        <div class="step-title">步骤 3: 滑动卷积核</div>
                        <div class="step-content">
                            <p>根据设定的步长，将卷积核向右移动相应的位置。步长为1时，每次移动一个像素；步长为2时，每次移动两个像素。</p>
                            <p>当卷积核移动到输入特征图的最右侧时，返回到最左侧的下一行，继续滑动过程。</p>
                            <p>这种滑动方式确保卷积核覆盖整个输入特征图，提取不同位置的特征信息。</p>
                        </div>
                    </div>
                    
                    <div class="step" id="step4">
                        <div class="step-title">步骤 4: 生成输出特征图</div>
                        <div class="step-content">
                            <p>卷积核在输入特征图上滑动完成后，所有计算结果组成了输出特征图（黄色）。</p>
                            <p>输出特征图的尺寸由输入尺寸、卷积核尺寸、步长和填充共同决定。公式如下：</p>
                            <p class="formula">输出尺寸 = ⌊(输入尺寸 + 2×填充 - 卷积核尺寸) / 步长⌋ + 1</p>
                            <p>输出特征图中的每个值都代表了输入中特定特征的检测结果，这些特征可用于后续的分类或识别任务。</p>
                        </div>
                    </div>
                    
                    <div class="step" id="step5">
                        <div class="step-title">步骤 5: 填充的作用</div>
                        <div class="step-content">
                            <p>填充是在输入特征图周围添加额外的像素（通常为0），以控制输出特征图的尺寸。</p>
                            <p><span class="highlight">相同填充</span>：添加足够的填充，使输出特征图与输入特征图尺寸相同。</p>
                            <p><span class="highlight">有效填充</span>：不添加填充，输出特征图尺寸会缩小。</p>
                            <p>填充可以防止信息丢失，尤其是在深层网络中，可以保持特征图的尺寸，避免过度缩小。</p>
                        </div>
                    </div>
                </div>
                
                <div class="step-navigation">
                    <button id="prevStep"><i class="fas fa-chevron-left"></i> 上一步</button>
                    
                    <div class="step-counter">
                        <span>步骤</span>
                        <div class="step-dots">
                            <div class="step-dot active" data-step="1"></div>
                            <div class="step-dot" data-step="2"></div>
                            <div class="step-dot" data-step="3"></div>
                            <div class="step-dot" data-step="4"></div>
                            <div class="step-dot" data-step="5"></div>
                        </div>
                    </div>
                    
                    <button id="nextStep">下一步 <i class="fas fa-chevron-right"></i></button>
                </div>
            </section>
        </div>
        
        <footer>
            <p>卷积神经网络 (CNN) 是深度学习中最重要的架构之一，广泛应用于图像识别、计算机视觉等领域。</p>
            <p>通过调整上方的参数，观察卷积操作如何提取输入数据中的特征。</p>
            <div class="ai-badge">深度学习科普演示</div>
        </footer>
    </div>

    <script>
        // 获取Canvas和上下文
        const canvas = document.getElementById('convCanvas');
        const ctx = canvas.getContext('2d');
        
        // 设置Canvas尺寸
        function resizeCanvas() {
            const container = document.getElementById('canvas-container');
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
        }
        
        // 初始调整Canvas大小
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        
        // 状态变量
        let animationId = null;
        let isAnimating = false;
        let currentStep = 1;
        const totalSteps = 5;
        
        // 卷积参数
        let params = {
            inputSize: 9,        // 输入特征图尺寸 (inputSize x inputSize)
            kernelSize: 3,       // 卷积核尺寸 (kernelSize x kernelSize)
            stride: 1,           // 步长
            padding: 0,          // 填充
            speed: 5,            // 动画速度 (1-10)
            currentPosition: { x: 0, y: 0 }, // 当前卷积核位置
            outputSize: 7        // 输出特征图尺寸
        };
        
        // 输入、卷积核和输出数据
        let inputData = [];
        let kernelData = [];
        let outputData = [];
        
        // 颜色定义
        const colors = {
            input: '#3b82f6',
            kernel: '#10b981',
            output: '#f59e0b',
            active: '#ef4444',
            background: '#1e293b',
            grid: '#475569',
            text: '#e2e8f0'
        };
        
        // 初始化数据
        function initData() {
            // 生成随机输入数据
            inputData = [];
            for (let i = 0; i < params.inputSize; i++) {
                inputData[i] = [];
                for (let j = 0; j < params.inputSize; j++) {
                    // 生成一些模式，使卷积效果更明显
                    const patternValue = Math.sin(i * 0.7) * Math.cos(j * 0.7);
                    const randomValue = Math.random() * 0.3;
                    inputData[i][j] = Math.max(0.1, Math.min(0.9, 0.5 + patternValue * 0.3 + randomValue));
                }
            }
            
            // 生成卷积核数据（简单的边缘检测核）
            kernelData = [];
            for (let i = 0; i < params.kernelSize; i++) {
                kernelData[i] = [];
                for (let j = 0; j < params.kernelSize; j++) {
                    // 创建简单的边缘检测核
                    if (i === Math.floor(params.kernelSize / 2) && j === Math.floor(params.kernelSize / 2)) {
                        kernelData[i][j] = params.kernelSize * params.kernelSize - 1;
                    } else {
                        kernelData[i][j] = -1;
                    }
                }
            }
            
            // 归一化卷积核
            let sum = 0;
            for (let i = 0; i < params.kernelSize; i++) {
                for (let j = 0; j < params.kernelSize; j++) {
                    sum += kernelData[i][j];
                }
            }
            
            if (sum !== 0) {
                for (let i = 0; i < params.kernelSize; i++) {
                    for (let j = 0; j < params.kernelSize; j++) {
                        kernelData[i][j] /= sum;
                    }
                }
            }
            
            // 计算输出尺寸
            params.outputSize = Math.floor((params.inputSize + 2 * params.padding - params.kernelSize) / params.stride) + 1;
            
            // 初始化输出数据
            outputData = [];
            for (let i = 0; i < params.outputSize; i++) {
                outputData[i] = [];
                for (let j = 0; j < params.outputSize; j++) {
                    outputData[i][j] = 0;
                }
            }
            
            // 重置当前位置
            params.currentPosition = { x: 0, y: 0 };
        }
        
        // 计算单个卷积操作
        function computeConvolutionAt(x, y) {
            let sum = 0;
            
            // 考虑填充
            const paddedX = x * params.stride;
            const paddedY = y * params.stride;
            
            // 遍历卷积核
            for (let i = 0; i < params.kernelSize; i++) {
                for (let j = 0; j < params.kernelSize; j++) {
                    // 计算输入中的位置（考虑填充）
                    const inputX = paddedX + i - params.padding;
                    const inputY = paddedY + j - params.padding;
                    
                    // 检查是否在输入范围内
                    if (inputX >= 0 && inputX < params.inputSize && inputY >= 0 && inputY < params.inputSize) {
                        sum += inputData[inputX][inputY] * kernelData[i][j];
                    }
                    // 如果位置在填充区域，则输入值为0（不参与计算）
                }
            }
            
            // 应用激活函数（ReLU）
            return Math.max(0, sum);
        }
        
        // 绘制场景
        function drawScene() {
            // 清除Canvas
            ctx.fillStyle = colors.background;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // 计算布局参数
            const padding = 20;
            const inputCellSize = Math.min(
                (canvas.width - 3 * padding) / (params.inputSize + params.outputSize + 2),
                (canvas.height - 2 * padding) / Math.max(params.inputSize, params.outputSize + 2)
            );
            
            const kernelCellSize = inputCellSize * 0.8;
            const outputCellSize = inputCellSize;
            
            // 输入特征图位置
            const inputX = padding;
            const inputY = (canvas.height - params.inputSize * inputCellSize) / 2;
            
            // 输出特征图位置
            const outputX = inputX + (params.inputSize + 1) * inputCellSize;
            const outputY = (canvas.height - params.outputSize * outputCellSize) / 2;
            
            // 卷积核位置（在输入和输出之间）
            const kernelX = inputX + params.inputSize * inputCellSize + padding / 2;
            const kernelY = inputY + params.currentPosition.y * params.stride * inputCellSize + 
                           (params.currentPosition.x * params.stride * inputCellSize) / params.inputSize;
            
            // 绘制输入特征图
            drawMatrix(inputData, inputX, inputY, inputCellSize, colors.input, "输入特征图");
            
            // 绘制卷积核
            drawMatrix(kernelData, kernelX, kernelY, kernelCellSize, colors.kernel, "卷积核");
            
            // 绘制输出特征图
            drawMatrix(outputData, outputX, outputY, outputCellSize, colors.output, "输出特征图");
            
            // 绘制当前卷积区域（红色框）
            drawActiveRegion(inputX, inputY, inputCellSize);
            
            // 绘制连接线（从卷积核到输出）
            drawConnectionLines(inputX, inputY, inputCellSize, outputX, outputY, outputCellSize);
            
            // 绘制当前步骤信息
            drawStepInfo();
        }
        
        // 绘制矩阵
        function drawMatrix(matrix, x, y, cellSize, color, label) {
            const rows = matrix.length;
            const cols = matrix[0] ? matrix[0].length : 0;
            
            // 绘制矩阵背景
            ctx.fillStyle = color + '20';
            ctx.fillRect(x - 5, y - 5, cols * cellSize + 10, rows * cellSize + 10);
            
            // 绘制矩阵格子
            for (let i = 0; i < rows; i++) {
                for (let j = 0; j < cols; j++) {
                    const cellX = x + j * cellSize;
                    const cellY = y + i * cellSize;
                    
                    // 根据值设置颜色深浅
                    const value = matrix[i][j];
                    const intensity = Math.max(0.2, Math.min(1, value));
                    
                    ctx.fillStyle = color;
                    ctx.globalAlpha = intensity;
                    ctx.fillRect(cellX, cellY, cellSize - 1, cellSize - 1);
                    
                    // 绘制网格线
                    ctx.strokeStyle = colors.grid;
                    ctx.globalAlpha = 0.5;
                    ctx.lineWidth = 1;
                    ctx.strokeRect(cellX, cellY, cellSize, cellSize);
                    
                    // 绘制值（如果是卷积核或小矩阵）
                    if (cellSize > 20 && rows <= 5 && cols <= 5) {
                        ctx.fillStyle = colors.text;
                        ctx.globalAlpha = 1;
                        ctx.font = `${Math.max(10, cellSize/3)}px Arial`;
                        ctx.textAlign = "center";
                        ctx.textBaseline = "middle";
                        ctx.fillText(
                            value.toFixed(1), 
                            cellX + cellSize/2, 
                            cellY + cellSize/2
                        );
                    }
                }
            }
            
            ctx.globalAlpha = 1;
            
            // 绘制标签
            ctx.fillStyle = colors.text;
            ctx.font = "16px Arial";
            ctx.textAlign = "center";
            ctx.textBaseline = "top";
            ctx.fillText(label, x + cols * cellSize / 2, y + rows * cellSize + 15);
        }
        
        // 绘制当前激活区域（红色框）
        function drawActiveRegion(inputX, inputY, cellSize) {
            const startX = inputX + params.currentPosition.y * params.stride * cellSize - params.padding * cellSize;
            const startY = inputY + params.currentPosition.x * params.stride * cellSize - params.padding * cellSize;
            const regionSize = params.kernelSize * cellSize;
            
            ctx.strokeStyle = colors.active;
            ctx.lineWidth = 3;
            ctx.setLineDash([5, 5]);
            ctx.strokeRect(startX, startY, regionSize, regionSize);
            ctx.setLineDash([]);
        }
        
        // 绘制连接线
        function drawConnectionLines(inputX, inputY, inputCellSize, outputX, outputY, outputCellSize) {
            // 从激活区域中心到卷积核
            const activeCenterX = inputX + (params.currentPosition.y * params.stride + params.kernelSize/2 - params.padding) * inputCellSize;
            const activeCenterY = inputY + (params.currentPosition.x * params.stride + params.kernelSize/2 - params.padding) * inputCellSize;
            
            // 卷积核中心
            const kernelX = inputX + params.inputSize * inputCellSize + 20;
            const kernelY = activeCenterY;
            
            // 输出对应位置
            const outputCenterX = outputX + (params.currentPosition.y + 0.5) * outputCellSize;
            const outputCenterY = outputY + (params.currentPosition.x + 0.5) * outputCellSize;
            
            // 绘制从激活区域到卷积核的线
            ctx.strokeStyle = colors.active + '80';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(activeCenterX, activeCenterY);
            ctx.lineTo(kernelX, kernelY);
            ctx.stroke();
            
            // 绘制从卷积核到输出的线
            ctx.strokeStyle = colors.kernel + '80';
            ctx.beginPath();
            ctx.moveTo(kernelX + 30, kernelY);
            ctx.lineTo(outputCenterX, outputCenterY);
            ctx.stroke();
            
            // 绘制输出当前位置
            ctx.fillStyle = colors.active + '40';
            ctx.fillRect(
                outputX + params.currentPosition.y * outputCellSize,
                outputY + params.currentPosition.x * outputCellSize,
                outputCellSize,
                outputCellSize
            );
        }
        
        // 绘制当前步骤信息（DOM方式）
        function drawStepInfo() {
            const infoDisplay = document.getElementById('stepInfoDisplay');
            if (!infoDisplay) return;
            
            infoDisplay.innerHTML = `
                <div class="info-item">
                    <span class="info-label">步骤</span>
                    <span class="info-value">${currentStep}/5</span>
                </div>
                <div class="info-item">
                    <span class="info-label">位置</span>
                    <span class="info-value">(${params.currentPosition.x}, ${params.currentPosition.y})</span>
                </div>
                <div class="info-item">
                    <span class="info-label">输出尺寸</span>
                    <span class="info-value">${params.outputSize}×${params.outputSize}</span>
                </div>
                <div class="info-item">
                    <span class="info-label">卷积核</span>
                    <span class="info-value">${params.kernelSize}×${params.kernelSize}</span>
                </div>
                <div class="info-item">
                    <span class="info-label">参数</span>
                    <span class="info-value">S:${params.stride} P:${params.padding}</span>
                </div>
            `;
        }
        
        // 执行单步卷积
        function performConvolutionStep() {
            // 计算当前位置的卷积结果
            const result = computeConvolutionAt(params.currentPosition.x, params.currentPosition.y);
            outputData[params.currentPosition.x][params.currentPosition.y] = result;
            
            // 移动到下一个位置
            params.currentPosition.y++;
            
            // 如果到达当前行的末尾，移动到下一行
            if (params.currentPosition.y >= params.outputSize) {
                params.currentPosition.y = 0;
                params.currentPosition.x++;
                
                // 如果完成了所有位置，停止动画
                if (params.currentPosition.x >= params.outputSize) {
                    stopAnimation();
                    return false;
                }
            }
            
            return true;
        }
        
        // 开始动画
        function startAnimation() {
            if (isAnimating) return;
            
            isAnimating = true;
            document.getElementById('startBtn').innerHTML = '<i class="fas fa-pause"></i> 暂停';
            
            // 如果已经完成，重新开始
            if (params.currentPosition.x >= params.outputSize - 1 && 
                params.currentPosition.y >= params.outputSize - 1) {
                resetAnimation();
            }
            
            animate();
        }
        
        // 动画循环
        function animate() {
            if (!isAnimating) return;
            
            // 根据速度计算每帧执行的步骤数
            const stepsPerFrame = Math.max(1, Math.floor(params.speed / 2));
            
            for (let i = 0; i < stepsPerFrame; i++) {
                const hasMoreSteps = performConvolutionStep();
                if (!hasMoreSteps) break;
            }
            
            drawScene();
            
            // 继续动画
            animationId = requestAnimationFrame(animate);
        }
        
        // 停止动画
        function stopAnimation() {
            isAnimating = false;
            document.getElementById('startBtn').innerHTML = '<i class="fas fa-play"></i> 开始卷积';
            
            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }
        }
        
        // 重置动画
        function resetAnimation() {
            stopAnimation();
            initData();
            drawScene();
            currentStep = 1;
            updateStepDisplay();
        }
        
        // 单步执行
        function stepAnimation() {
            stopAnimation();
            const hasMoreSteps = performConvolutionStep();
            drawScene();
            
            // 如果没有更多步骤，显示完成消息
            if (!hasMoreSteps) {
                alert("卷积操作完成！输出特征图已生成。");
            }
        }
        
        // 更新步骤显示
        function updateStepDisplay() {
            // 隐藏所有步骤
            for (let i = 1; i <= totalSteps; i++) {
                document.getElementById(`step${i}`).classList.remove('active');
                document.querySelector(`.step-dot[data-step="${i}"]`).classList.remove('active');
            }
            
            // 显示当前步骤
            document.getElementById(`step${currentStep}`).classList.add('active');
            document.querySelector(`.step-dot[data-step="${currentStep}"]`).classList.add('active');
        }
        
        // 下一步
        function nextStep() {
            if (currentStep < totalSteps) {
                currentStep++;
                updateStepDisplay();
            }
        }
        
        // 上一步
        function prevStep() {
            if (currentStep > 1) {
                currentStep--;
                updateStepDisplay();
            }
        }
        
        // 更新参数显示
        function updateParamDisplays() {
            document.getElementById('kernelSizeValue').textContent = `${params.kernelSize}×${params.kernelSize}`;
            document.getElementById('strideValue').textContent = params.stride;
            document.getElementById('paddingValue').textContent = params.padding;
            document.getElementById('speedValue').textContent = params.speed;
        }
        
        // 初始化
        function init() {
            // 设置初始参数
            updateParamDisplays();
            
            // 初始化数据并绘制场景
            initData();
            drawScene();
            
            // 设置事件监听器
            document.getElementById('startBtn').addEventListener('click', function() {
                if (isAnimating) {
                    stopAnimation();
                } else {
                    startAnimation();
                }
            });
            
            document.getElementById('resetBtn').addEventListener('click', resetAnimation);
            document.getElementById('stepBtn').addEventListener('click', stepAnimation);
            document.getElementById('prevStep').addEventListener('click', prevStep);
            document.getElementById('nextStep').addEventListener('click', nextStep);
            
            // 步骤点点击事件
            document.querySelectorAll('.step-dot').forEach(dot => {
                dot.addEventListener('click', function() {
                    currentStep = parseInt(this.getAttribute('data-step'));
                    updateStepDisplay();
                });
            });
            
            // 参数滑块事件
            document.getElementById('kernelSize').addEventListener('input', function() {
                params.kernelSize = parseInt(this.value);
                updateParamDisplays();
                resetAnimation();
            });
            
            document.getElementById('stride').addEventListener('input', function() {
                params.stride = parseInt(this.value);
                updateParamDisplays();
                resetAnimation();
            });
            
            document.getElementById('padding').addEventListener('input', function() {
                params.padding = parseInt(this.value);
                updateParamDisplays();
                resetAnimation();
            });
            
            document.getElementById('speed').addEventListener('input', function() {
                params.speed = parseInt(this.value);
                updateParamDisplays();
            });
            
            // 初始显示第一步
            updateStepDisplay();
        }
        
        // 页面加载完成后初始化
        window.addEventListener('load', init);
    </script>
</body>
</html>